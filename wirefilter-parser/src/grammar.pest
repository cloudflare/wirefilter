// Identifiers
//============================================================
identifier = _{ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* }
variable_name = @{ identifier ~ ("." ~ identifier)* }


// Rhs
//============================================================
rhs = { int_range_inclusive | int_literal }

// Int
int_literal = ${ "-"? ~ digits }
digits = _{ oct_digits | ("0x" ~ hex_digits) | dec_digits }
hex_digits = { ASCII_HEX_DIGIT+ }
oct_digits = { "0" ~ ASCII_OCT_DIGIT+ }
dec_digits = { ASCII_DIGIT+ }

// Int range (inclusive)
int_range_inclusive = ${ int_literal ~ ".." ~ int_literal }


// Operators
//============================================================

// Logical operators
logical_operator = { op_or | op_and | op_xor }

op_or = { "||" | "or" }
op_and = { "&&" | "and" }
op_xor = { "^^" | "xor" }

// Binary operators
binary_operator = { comparison_operator | int_operator | bytes_operator | collection_operator }

comparison_operator = { op_eq | op_ne | op_ge | op_le | op_gt | op_lt }
op_eq = { "==" | "eq" }
op_ne = { "!=" | "ne" }
op_ge = { ">=" | "ge" }
op_le = { "<=" | "le" }
op_gt = { ">" | "gt" }
op_lt = { "<" | "lt" }

int_operator = { op_bitwise_and }
op_bitwise_and = { "&" | "bitwise_and" }

bytes_operator = { op_contains | op_matches }
op_contains = { "contains" }
op_matches = { "~" | "matches" }

collection_operator = { op_in }
op_in = { "in" }


// Expression
//============================================================
filter = { SOI ~ compound_expr ~ EOI }

compound_expr = { term ~ (logical_operator ~ term)* }
term = _{ expr | "(" ~ compound_expr ~ ")" }
expr = { variable_name ~ binary_operator ~ rhs }


// Trivia
//============================================================
WHITESPACE = _{ " " | NEWLINE }
